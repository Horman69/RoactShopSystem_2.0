--!strict
-- src/App/ProductCard.luau
-- –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –∫–∞—Ä—Ç–æ—á–∫–∏ —Ç–æ–≤–∞—Ä–∞ –¥–ª—è –º–∞–≥–∞–∑–∏–Ω–∞
-- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤—Å–µ —Ç–∏–ø—ã —Ç–æ–≤–∞—Ä–æ–≤ —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º –¥–∏–∑–∞–π–Ω–æ–º

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
local ModuleLoader = require(ReplicatedStorage:WaitForChild("shared"):WaitForChild("ModuleLoader"))
local Roact = ModuleLoader.require("Packages/roact")
local PlatformService = ModuleLoader.require("services/SimplePlatformService")

-- –¢–∏–ø—ã –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
local Types = require(ReplicatedStorage:WaitForChild("shared"):WaitForChild("Types"))
local ShopConfig = require(ReplicatedStorage:WaitForChild("shared"):WaitForChild("ShopConfig"))
type Product = Types.Product

-- –ü—Ä–æ–ø—Å—ã –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
export type ProductCardProps = {
	product: Product,
	isOwned: boolean?,
	canAfford: boolean?,
	onPurchase: (product: Product) -> (),
}

-- –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∫–∞—Ä—Ç–æ—á–∫–∏ —Ç–æ–≤–∞—Ä–∞
local ProductCard = Roact.Component:extend("ProductCard")

function ProductCard:init()
	self.platformService = PlatformService.new()
	self.strokeRef = Roact.createRef() -- –î–ª—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –Ω–∞–≤–µ–¥–µ–Ω–∏—è
end

-- –ü–æ–ª—É—á–∏—Ç—å –∏–∫–æ–Ω–∫—É –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Ç–æ–≤–∞—Ä–∞
function ProductCard:getCategoryIcon(category: string?): string
	local categoryConfig = ShopConfig.getCategoryConfig(category or "other")
	return categoryConfig.icon
end

-- –ü–æ–ª—É—á–∏—Ç—å —Ü–≤–µ—Ç –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
function ProductCard:getCategoryColor(category: string?): Color3
	local categoryConfig = ShopConfig.getCategoryConfig(category or "other")
	return categoryConfig.color
end

-- –ü–æ–ª—É—á–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏
function ProductCard:getButtonState(): (string, Color3, boolean)
	local isOwned = self.props.isOwned or false
	local canAfford = self.props.canAfford or true
	
	if isOwned then
		return ShopConfig.shop.buttons.owned, ShopConfig.design.colors.button.owned, false
	elseif not canAfford then
		return ShopConfig.shop.buttons.cantAfford, ShopConfig.design.colors.button.cantAfford, false
	else
		return ShopConfig.shop.buttons.buy, ShopConfig.design.colors.button.buy, true
	end
end

-- –≠—Ñ—Ñ–µ–∫—Ç –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ –º—ã—à–∏ (–∫–∞–∫ —É —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π)
function ProductCard:onCardHover(isHovering: boolean)
	local stroke = self.strokeRef.current
	if stroke then
		local targetTransparency = isHovering and 0.1 or 0.3
		local tween = TweenService:Create(stroke,
			TweenInfo.new(ShopConfig.design.animations.fast, ShopConfig.design.animations.easing, ShopConfig.design.animations.direction),
			{ Transparency = targetTransparency }
		)
		tween:Play()
	end
end

function ProductCard:render()
	local product = self.props.product
	local isMobile = self.platformService:isMobile()
	
	-- –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç–∏
	local responsiveConfig = ShopConfig.getResponsiveConfig(isMobile)
	local cardDimensions = ShopConfig.getCardDimensions(isMobile)
	
	-- –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
	local categoryIcon = self:getCategoryIcon(product.category)
	local categoryColor = self:getCategoryColor(product.category)
	local buttonText, buttonColor, buttonEnabled = self:getButtonState()
	
	-- –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
	local cardHeight = cardDimensions.height
	local spacing = cardDimensions.spacing
	local typography = responsiveConfig.typography
	local iconSize = isMobile and 28 or 32
	local buttonWidth = isMobile and 85 or 95
	local buttonHeight = cardDimensions.buttonHeight
	
	return Roact.createElement("Frame", {
		Size = UDim2.new(1, 0, 0, cardHeight),
		BackgroundColor3 = ShopConfig.design.colors.cardBackground,
		BackgroundTransparency = 0,
		BorderSizePixel = 0,
		
		-- –°–æ–±—ã—Ç–∏—è –Ω–∞–≤–µ–¥–µ–Ω–∏—è (–∫–∞–∫ —É —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π)
		[Roact.Event.MouseEnter] = function()
			self:onCardHover(true)
		end,
		[Roact.Event.MouseLeave] = function()
			self:onCardHover(false)
		end,
	}, {
		-- –°–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∫–∞–∫ —É –∏–∫–æ–Ω–æ–∫ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
		UICorner = Roact.createElement("UICorner", {
			CornerRadius = UDim.new(0, ShopConfig.design.borderRadius.medium),
		}),
		
		-- –°–≤–µ—Ç—è—â–∞—è—Å—è –æ–±–≤–æ–¥–∫–∞ –∫–∞–∫ —É –∏–∫–æ–Ω–æ–∫ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
		UIStroke = Roact.createElement("UIStroke", {
			Color = categoryColor,
			Thickness = 2,
			Transparency = 0.3,
			[Roact.Ref] = self.strokeRef, -- –î–æ–±–∞–≤–ª—è–µ–º ref –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
		}),
		
		-- –¢–µ–Ω—å –¥–ª—è –≥–ª—É–±–∏–Ω—ã
		Shadow = Roact.createElement("Frame", {
			Size = UDim2.new(1, 4, 1, 6),
			Position = UDim2.new(0, 2, 0, 3),
			BackgroundColor3 = ShopConfig.design.colors.shadow,
			BackgroundTransparency = 0.85,
			BorderSizePixel = 0,
			ZIndex = -1,
		}, {
			UICorner = Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, ShopConfig.design.borderRadius.medium),
			}),
		}),
		
		-- –°—Ç–∏–ª—å–Ω–∞—è –∏–∫–æ–Ω–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤ —Å—Ç–∏–ª–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
		CategoryIcon = Roact.createElement("Frame", {
			Size = UDim2.new(0, iconSize + 8, 0, iconSize + 8),
			Position = UDim2.new(0, ShopConfig.design.spacing.padding.medium + 6, 0, ShopConfig.design.spacing.gaps.medium),
			BackgroundColor3 = categoryColor,
			BackgroundTransparency = 0.8,
			BorderSizePixel = 0,
		}, {
			UICorner = Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, ShopConfig.design.borderRadius.round), -- –ö—Ä—É–≥–ª–∞—è –∏–∫–æ–Ω–∫–∞
			}),
			
			-- –°–≤–µ—Ç—è—â–∞—è—Å—è –æ–±–≤–æ–¥–∫–∞ –∏–∫–æ–Ω–∫–∏
			UIStroke = Roact.createElement("UIStroke", {
				Color = categoryColor,
				Thickness = 2,
				Transparency = 0.3,
			}),
			
			Icon = Roact.createElement("TextLabel", {
				Text = categoryIcon,
				Size = UDim2.new(1, 0, 1, 0),
				BackgroundTransparency = 1,
				TextColor3 = categoryColor,
				TextSize = iconSize * 0.8,
				Font = Enum.Font.GothamBold,
				TextXAlignment = Enum.TextXAlignment.Center,
				TextYAlignment = Enum.TextYAlignment.Center,
			}),
		}),
		
		-- –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–æ–≤–∞—Ä–µ
		ProductInfo = Roact.createElement("Frame", {
			Size = UDim2.new(1, -(buttonWidth + ShopConfig.design.spacing.padding.large), 1, -ShopConfig.design.spacing.gaps.large),
			Position = UDim2.new(0, iconSize + ShopConfig.design.spacing.padding.large + 8, 0, ShopConfig.design.spacing.gaps.medium),
			BackgroundTransparency = 1,
		}, {
			-- –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞
			ProductName = Roact.createElement("TextLabel", {
				Text = product.name,
				Size = UDim2.new(1, 0, 0, typography.title + 2),
				Position = UDim2.new(0, 0, 0, 2),
				BackgroundTransparency = 1,
				TextColor3 = ShopConfig.design.colors.text.primary,
				TextSize = typography.title,
				Font = Enum.Font.GothamBold,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextTruncate = Enum.TextTruncate.AtEnd,
			}),
			
			-- –¶–µ–Ω–∞ —Ç–æ–≤–∞—Ä–∞
			ProductPrice = Roact.createElement("TextLabel", {
				Text = "üí∞ " .. product.price .. " –º–æ–Ω–µ—Ç",
				Size = UDim2.new(1, 0, 0, typography.price + 2),
				Position = UDim2.new(0, 0, 0, typography.title + ShopConfig.design.spacing.gaps.small),
				BackgroundTransparency = 1,
				TextColor3 = ShopConfig.design.colors.text.accent,
				TextSize = typography.price,
				Font = Enum.Font.GothamBold,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
			}),
			
			-- –û–ø–∏—Å–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞  
			ProductDescription = Roact.createElement("TextLabel", {
				Text = product.description,
				Size = UDim2.new(1, 0, 0, typography.description + 8),
				Position = UDim2.new(0, 0, 0, typography.title + typography.price + ShopConfig.design.spacing.gaps.medium),
				BackgroundTransparency = 1,
				TextColor3 = ShopConfig.design.colors.text.secondary,
				TextSize = typography.description,
				Font = Enum.Font.Gotham,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextWrapped = true,
				TextTruncate = Enum.TextTruncate.AtEnd,
			}),
		}),
		
		-- –°—Ç–∏–ª—å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ –ø–æ–∫—É–ø–∫–∏ —Å —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏
		PurchaseButton = Roact.createElement("TextButton", {
			Text = buttonText,
			Size = UDim2.new(0, buttonWidth, 0, buttonHeight),
			Position = UDim2.new(1, -(buttonWidth + ShopConfig.design.spacing.padding.medium), 0.5, -buttonHeight / 2),
			BackgroundColor3 = buttonColor,
			BackgroundTransparency = 0,
			BorderSizePixel = 0,
			Active = buttonEnabled,
			TextColor3 = Color3.fromRGB(255, 255, 255),
			TextSize = typography.button,
			Font = Enum.Font.GothamBold,
			AutoButtonColor = false,
			Modal = true, -- –î–û–ë–ê–í–õ–ï–ù–û: –æ—Ç–∫–ª—é—á–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–≤—É–∫–∏ Roblox
			
			[Roact.Event.Activated] = buttonEnabled and function()
				self.props.onPurchase(product)
			end or nil,
		}, {
			-- –°–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏
			UICorner = Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, ShopConfig.design.borderRadius.medium),
			}),
			
			-- –°–≤–µ—Ç—è—â–∞—è—Å—è –æ–±–≤–æ–¥–∫–∞ –∫–Ω–æ–ø–∫–∏
			UIStroke = buttonEnabled and Roact.createElement("UIStroke", {
				Color = buttonColor,
				Thickness = 1,
				Transparency = 0.6,
			}) or nil,
			
			-- –ì—Ä–∞–¥–∏–µ–Ω—Ç –∫–Ω–æ–ø–∫–∏
			UIGradient = buttonEnabled and Roact.createElement("UIGradient", {
				Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, buttonColor),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(
						math.max(0, buttonColor.R * 255 - 30) / 255,
						math.max(0, buttonColor.G * 255 - 30) / 255,
						math.max(0, buttonColor.B * 255 - 30) / 255
					)),
				}),
				Rotation = 90,
			}) or nil,
			
			-- –¢–µ–Ω—å –∫–Ω–æ–ø–∫–∏
			ButtonShadow = Roact.createElement("Frame", {
				Size = UDim2.new(1, 4, 1, 6),
				Position = UDim2.new(0, 2, 0, 3),
				BackgroundColor3 = buttonColor,
				BackgroundTransparency = 0.8,
				BorderSizePixel = 0,
				ZIndex = -1,
			}, {
				UICorner = Roact.createElement("UICorner", {
					CornerRadius = UDim.new(0, ShopConfig.design.borderRadius.medium),
				}),
			}),
		}),
	})
end

return ProductCard
