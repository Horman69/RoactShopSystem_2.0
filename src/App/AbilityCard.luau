--!strict
-- src/App/AbilityCard.luau
-- –ü—Ä–æ—Å—Ç–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –∫–∞—Ä—Ç–æ—á–∫–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –¥–ª—è –º–∞–≥–∞–∑–∏–Ω–∞
-- –ú–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –¥–∏–∑–∞–π–Ω —Å –∫—Ä—É–ø–Ω—ã–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

-- –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
local ModuleLoader = require(ReplicatedStorage:WaitForChild("shared"):WaitForChild("ModuleLoader"))
local Roact = ModuleLoader.require("Packages/roact")
local PlatformService = ModuleLoader.require("services/SimplePlatformService")

-- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
local ShopConfig = require(ReplicatedStorage:WaitForChild("shared"):WaitForChild("ShopConfig"))

-- –¢–∏–ø—ã
local Types = require(ReplicatedStorage:WaitForChild("shared"):WaitForChild("Types"))
type Ability = Types.Ability

-- –ü—Ä–æ–ø—Å—ã –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
export type AbilityCardProps = {
	ability: Ability,
	isOwned: boolean?,
	canAfford: boolean?,
	onPurchase: (ability: Ability) -> (),
}

-- –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∫–∞—Ä—Ç–æ—á–∫–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
local AbilityCard = Roact.Component:extend("AbilityCard")

function AbilityCard:init()
	self.platformService = PlatformService.new()
	self.buttonRef = Roact.createRef()
	self.strokeRef = Roact.createRef()
	self.cardRef = Roact.createRef()
	
	-- –°–æ—Å—Ç–æ—è–Ω–∏–µ hover
	self:setState({
		isHovered = false,
	})
end

-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫—É —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
function AbilityCard:onCardHover(isHovering: boolean)
	if self.platformService:isMobile() then return end
	
	self:setState({ isHovered = isHovering })
	
	-- –≠—Ñ—Ñ–µ–∫—Ç –¥–ª—è –æ–±–≤–æ–¥–∫–∏
	if self.strokeRef.current then
		local targetTransparency = isHovering and 0.1 or 0.4
		local strokeTween = TweenService:Create(self.strokeRef.current,
			TweenInfo.new(ShopConfig.design.animations.duration, ShopConfig.design.animations.easing),
			{ Transparency = targetTransparency }
		)
		strokeTween:Play()
	end
	
	-- –ü–ª–∞–≤–Ω—ã–π hover-—ç—Ñ—Ñ–µ–∫—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞—Ä—Ç–æ—á–∫–∏
	if self.cardRef.current then
		local targetScale = isHovering and 1.02 or 1.0
		local scaleTween = TweenService:Create(self.cardRef.current,
			TweenInfo.new(ShopConfig.design.animations.duration, ShopConfig.design.animations.easing),
			{ Size = UDim2.new(targetScale, 0, targetScale, 0) }
		)
		scaleTween:Play()
	end
end

-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –ø—Ä–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏ —Å –∫–Ω–æ–ø–∫–æ–π
function AbilityCard:onButtonHover(isHovering: boolean)
	local button = self.buttonRef.current
	if button then
		local targetScale = isHovering and 1.05 or 1.0
		local targetTransparency = isHovering and 0.1 or 0.0
		
		local scaleTween = TweenService:Create(button,
			TweenInfo.new(ShopConfig.design.animations.duration, ShopConfig.design.animations.easing),
			{ 
				Size = UDim2.new(0, button.Size.X.Offset * targetScale, 0, button.Size.Y.Offset * targetScale),
				BackgroundTransparency = targetTransparency
			}
		)
		scaleTween:Play()
	end
end

function AbilityCard:onButtonPress()
	local button = self.buttonRef.current
	if button then
		-- –ë—ã—Å—Ç—Ä—ã–π —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞–∂–∞—Ç–∏—è
		local pressTween = TweenService:Create(button,
			TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
			{ Size = UDim2.new(0, button.Size.X.Offset * 0.95, 0, button.Size.Y.Offset * 0.95) }
		)
		pressTween:Play()
		
		-- –í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –∫ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º—É —Ä–∞–∑–º–µ—Ä—É
		pressTween.Completed:Connect(function()
			local releaseTween = TweenService:Create(button,
				TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
				{ Size = UDim2.new(0, button.Size.X.Offset / 0.95, 0, button.Size.Y.Offset / 0.95) }
			)
			releaseTween:Play()
		end)
	end
end

-- –ü–æ–ª—É—á–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ (—É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ)
function AbilityCard:getButtonState(): (string, Color3, boolean)
	local isOwned = self.props.isOwned or false
	local canAfford = self.props.canAfford or true
	
	if isOwned then
		return ShopConfig.shop.buttons.owned, ShopConfig.design.colors.button.owned, false
	elseif not canAfford then
		return ShopConfig.shop.buttons.cantAfford, ShopConfig.design.colors.button.cantAfford, false
	else
		return ShopConfig.shop.buttons.buy, ShopConfig.design.colors.button.buy, true
	end
end

function AbilityCard:render()
	local ability = self.props.ability
	local isMobile = self.platformService:isMobile()
	
	-- –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
	local config = ShopConfig.getResponsiveConfig(isMobile)
	local dimensions = ShopConfig.getCardDimensions(isMobile)
	local colors = ShopConfig.design.colors
	local animations = ShopConfig.design.animations
	
	-- –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
	local buttonText, buttonColor, buttonEnabled = self:getButtonState()
	
	-- –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–∑–º–µ—Ä—ã –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
	local cardHeight = dimensions.height
	local titleSize = config.typography.title
	local priceSize = config.typography.price
	local descSize = config.typography.description
	local buttonSize = isMobile and UDim2.new(0, 75, 0, dimensions.buttonHeight) or UDim2.new(0, 85, 0, dimensions.buttonHeight)
	
	return Roact.createElement("Frame", {
		Size = UDim2.new(1, 0, 0, cardHeight),
		BackgroundColor3 = ShopConfig.design.colors.background.card,
		BackgroundTransparency = 0,
		BorderSizePixel = 0,
		[Roact.Ref] = self.cardRef,
		
		-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è –Ω–∞–≤–µ–¥–µ–Ω–∏—è
		[Roact.Event.MouseEnter] = function()
			self:onCardHover(true)
		end,
		[Roact.Event.MouseLeave] = function()
			self:onCardHover(false)
		end,
	}, {
		-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Å–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏
		UICorner = Roact.createElement("UICorner", {
			CornerRadius = UDim.new(0, ShopConfig.design.borderRadius.card),
		}),
		
		-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç —Ñ–æ–Ω–∞ –¥–ª—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
		UIGradient = Roact.createElement("UIGradient", {
			Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, ShopConfig.design.colors.background.card),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(
					math.max(0, ShopConfig.design.colors.background.card.R * 255 - 15) / 255,
					math.max(0, ShopConfig.design.colors.background.card.G * 255 - 15) / 255,
					math.max(0, ShopConfig.design.colors.background.card.B * 255 - 15) / 255
				)),
			}),
			Rotation = 180,
		}),
		
		-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Å–≤–µ—Ç—è—â–∞—è—Å—è –æ–±–≤–æ–¥–∫–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏
		UIStroke = Roact.createElement("UIStroke", {
			Color = ShopConfig.design.colors.accent.primary,
			Thickness = ShopConfig.design.stroke.thickness,
			Transparency = 0.4,
			[Roact.Ref] = self.strokeRef,
		}),
		
		-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–µ–Ω—å –¥–ª—è –≥–ª—É–±–∏–Ω—ã
		Shadow = Roact.createElement("Frame", {
			Size = UDim2.new(1, ShopConfig.design.shadow.offset.x * 2, 1, ShopConfig.design.shadow.offset.y * 2),
			Position = UDim2.new(0, ShopConfig.design.shadow.offset.x, 0, ShopConfig.design.shadow.offset.y),
			BackgroundColor3 = ShopConfig.design.shadow.color,
			BackgroundTransparency = ShopConfig.design.shadow.transparency,
			BorderSizePixel = 0,
			ZIndex = -1,
		}, {
			UICorner = Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, ShopConfig.design.borderRadius.card),
			}),
		}),
		
		-- –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ (—Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è)
		AbilityInfo = Roact.createElement("Frame", {
			Size = UDim2.new(1, -100, 1, -config.spacing.gaps.medium), -- –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥
			Position = UDim2.new(0, config.spacing.padding.medium, 0, config.spacing.gaps.small),
			BackgroundTransparency = 1,
		}, {
			-- –ù–∞–∑–≤–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ (—Å–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–∏–ø–æ–≥—Ä–∞—Ñ–∏–∫–∞)
			AbilityName = Roact.createElement("TextLabel", {
				Text = ability.name,
				Size = UDim2.new(1, 0, 0, titleSize + 2),
				Position = UDim2.new(0, 0, 0, 8),
				BackgroundTransparency = 1,
				TextColor3 = ShopConfig.design.colors.text.primary,
				TextSize = titleSize,
				Font = ShopConfig.design.colors.text.fonts.bold,
				TextXAlignment = Enum.TextXAlignment.Center,
				TextYAlignment = Enum.TextYAlignment.Center,
				TextTruncate = Enum.TextTruncate.AtEnd,
			}),
			
			-- –¶–µ–Ω–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ (—Å –∑–æ–ª–æ—Ç—ã–º –∞–∫—Ü–µ–Ω—Ç–æ–º)
			AbilityPrice = Roact.createElement("TextLabel", {
				Text = "üí∞ " .. ability.price .. " –º–æ–Ω–µ—Ç",
				Size = UDim2.new(1, 0, 0, priceSize + 2),
				Position = UDim2.new(0, 0, 0, titleSize + 10),
				BackgroundTransparency = 1,
				TextColor3 = ShopConfig.design.colors.text.accent,
				TextSize = priceSize,
				Font = ShopConfig.design.colors.text.fonts.bold,
				TextXAlignment = Enum.TextXAlignment.Center,
				TextYAlignment = Enum.TextYAlignment.Center,
			}),
			
			-- –û–ø–∏—Å–∞–Ω–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ (—Å–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–∏–ø–æ–≥—Ä–∞—Ñ–∏–∫–∞)
			AbilityDescription = Roact.createElement("TextLabel", {
				Text = ability.description,
				Size = UDim2.new(1, 0, 0, descSize + 6),
				Position = UDim2.new(0, 0, 0, titleSize + priceSize + 15),
				BackgroundTransparency = 1,
				TextColor3 = ShopConfig.design.colors.text.secondary,
				TextSize = descSize,
				Font = ShopConfig.design.colors.text.fonts.regular,
				TextXAlignment = Enum.TextXAlignment.Center,
				TextYAlignment = Enum.TextYAlignment.Center,
				TextWrapped = true,
				TextTruncate = Enum.TextTruncate.AtEnd,
			}),
		}),
		
		-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è –∫–Ω–æ–ø–∫–∞ –ø–æ–∫—É–ø–∫–∏ —Å —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏
		PurchaseButton = Roact.createElement("TextButton", {
			Text = buttonText,
			Size = buttonSize,
			Position = UDim2.new(1, -buttonSize.X.Offset - 8, 0.5, -buttonSize.Y.Offset / 2),
			BackgroundColor3 = buttonColor,
			BackgroundTransparency = buttonEnabled and 0 or 0.3,
			BorderSizePixel = 0,
			TextColor3 = ShopConfig.design.colors.text.button,
			TextSize = isMobile and 12 or 13,
			Font = ShopConfig.design.colors.text.fonts.bold,
			AutoButtonColor = false,
			Modal = true, -- –û—Ç–∫–ª—é—á–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∑–≤—É–∫–∏ Roblox
			[Roact.Ref] = self.buttonRef,
			
			-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è –∫–Ω–æ–ø–∫–∏
			[Roact.Event.MouseEnter] = (not isMobile and buttonEnabled) and function()
				self:onButtonHover(true)
			end or nil,
			[Roact.Event.MouseLeave] = (not isMobile and buttonEnabled) and function()
				self:onButtonHover(false)
			end or nil,
			[Roact.Event.MouseButton1Down] = buttonEnabled and function()
				self:onButtonPress()
			end or nil,
			[Roact.Event.Activated] = buttonEnabled and function()
				if self.props.onPurchase then
					self.props.onPurchase(ability)
				end
			end or nil,
		}, {
			-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Å–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏
			UICorner = Roact.createElement("UICorner", {
				CornerRadius = UDim.new(0, ShopConfig.design.borderRadius.button),
			}),
			
			-- –°–≤–µ—Ç—è—â–∞—è—Å—è –æ–±–≤–æ–¥–∫–∞ –∫–Ω–æ–ø–∫–∏
			UIStroke = buttonEnabled and Roact.createElement("UIStroke", {
				Color = buttonColor,
				Thickness = ShopConfig.design.stroke.thickness,
				Transparency = 0.6,
			}) or nil,
			
			-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç –∫–Ω–æ–ø–∫–∏
			UIGradient = buttonEnabled and Roact.createElement("UIGradient", {
				Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, buttonColor),
					ColorSequenceKeypoint.new(1, Color3.fromRGB(
						math.max(0, buttonColor.R * 255 - 25) / 255,
						math.max(0, buttonColor.G * 255 - 25) / 255,
						math.max(0, buttonColor.B * 255 - 25) / 255
					)),
				}),
				Rotation = 90,
			}) or nil,
			
			-- –°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–µ–Ω—å –∫–Ω–æ–ø–∫–∏
			ButtonShadow = Roact.createElement("Frame", {
				Size = UDim2.new(1, ShopConfig.design.shadow.offset.x * 2, 1, ShopConfig.design.shadow.offset.y * 2),
				Position = UDim2.new(0, ShopConfig.design.shadow.offset.x, 0, ShopConfig.design.shadow.offset.y),
				BackgroundColor3 = buttonColor,
				BackgroundTransparency = 0.8,
				BorderSizePixel = 0,
				ZIndex = -1,
			}, {
				UICorner = Roact.createElement("UICorner", {
					CornerRadius = UDim.new(0, ShopConfig.design.borderRadius.button),
				}),
			}),
		}),
	})
end

return AbilityCard

